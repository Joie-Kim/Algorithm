# Greedy algorithm

## 특징

탐욕법(greedy algorithm, 욕심쟁이 알고리즘 또는 탐욕 알고리즘)이란 '매 선택에서 `지금 이 순간 당장 최적인 답`을 선택하여 적합한 결과를 도출하자'라는 모토를 가진다.<br>
동적 프로그래밍(dynamic programming) 사용 시, 지나치게 많은 일을 한다는 것에서 착안하여 고안된 알고리즘이다.<br>
동적 프로그래밍을 대체한다기 보다는 같이 쓰며 서로 보안하는 개념이다.<br>

> 어떻게 보안 되는지는 동적 프로그래밍 공부를 한 후에 알아봐야겠다.. 🙂

<br>

탐욕법을 사용하면 매 선택이 그 순간에는 최적이지만, 전체적으로 봤을 때 최적이라는 보장은 없다.<br>
아래 그림으로 이해 해보자.

![Greedy](https://user-images.githubusercontent.com/61102301/102688479-451d0c00-423a-11eb-8b9d-5fea1e8d506b.jpeg)
가장 숫자가 큰 요소를 찾는데 있어 해당 분기점마다 보다 큰 수를 찾는 방식으로 최종 해답을 찾아갔고(즉, 탐욕법을 이용했고), 최종 결과는 12가 된다.<br>
하지만 실제 전체 숫자 중 가장 큰 수는 99이다.<br>
이처럼 항상 전체 문제 해결에서의 최적의 해답을 찾는다고 보장할 수 없다.

<br>

## 어떤 경우에 적합한가?

탐욕법은 아래와 같은 특징을 가지는 문제들을 해결하는 데에 강점이 있다.

> - 탐욕 선택 속성 (greedy choice property)
> - 최적 부분 구조 (optimal substructure)

즉, 한 번의 선택이 다음 선택에는 전혀 무관한 값이어야 하고, 매 순간의 최적해가 전체 문제에 대한 최적해여야 한다.

예를 들어, 서울에서 대구를 경유해 부산까지 가는 최단 경로를 찾는다고 해보자.

> **서울 → 대구**
>
> - 250km
> - 200km
> - 300km
>
> ---
>
> **대구 → 부산**
>
> - 120km
> - 80km
> - 100km

이런 상황에서 최단 경로는 `200km(서울 → 대구) + 80km(대구 → 부산) = 280km` 이다.

위와 같이 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성될 때, 이런 구조를 최적 부분 구조라 한다.
