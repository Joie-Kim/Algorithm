# Stack

<p>
스택(stack)은 데이터를 임시 저장할 때 사용하는 자료구조

데이터의 입력과 출력 순서는 후입선출(LIFO) 방식

> LIFO (Last in first out)
: 가장 나중에 넣은 데이터를 가장 먼저 꺼냄

> 예를 들어 접시를 쌓아두고 맨 윗 접시를 꺼내는 상황을 생각하면 됨

스택에 데이터를 넣는 작업을 푸시(push)라 하고, 스택에서 데이터를 꺼내는 작업을 팝(pop)이라 함

윗 부분을 꼭대기(top)라 하고, 아랫 부분을 바닥(bottom)이라고 함

푸시한 데이터는 스택 꼭대기에 쌓임

팝을 할 때는 꼭대기에 있는 데이터가 꺼내지므로 팝을 하면 방금 푸시한(가장 최근에 푸시 한) 데이터를 꺼낼 수 있음
</p>

<br>

# Queue

<p>
큐(queue)는 스택과 같이 데이터를 임시 저장하는 자료구조

데이터의 입력과 출력 순서는 후입선출(FIFO) 방식

> FIFO (First in first out)
: 가장 먼저 넣은 데이터를 가장 먼저 꺼냄

> 예를 들어 은행 창구에서 차례를 기다리거나 마트에서 계산을 기다리는 줄을 생각하면 됨

큐에 데이터를 추가하는 작업을 인큐(enqueue), 데이터를 꺼내는 작업을 디큐(dequeue)라고 함

데이터를 꺼내는 쪽(맨 앞의 원소)을 프런트(front), 데이터를 넣는 쪽(맨 끝의 원소)을 리어(rear)라고 함
</p>

## 배열로 큐 구현하기
배열의 이름을 que라 하고, que[0] ~ que[3]에 int형 데이터가 저장되어 있다고 가정

### 인큐
맨 끝 데이터가 저장되어 있는 que[3]의 다음 원소인 que[4]에 데이터를 저장<br>
이때 처리 복잡도는 O(1)이고 비교적 적은 비용(cost)으로 구현할 수 있음

### 디큐
que[0]에 저장되어 있는 값을 꺼내면서 que[1]부터 모든 원소를 앞으로 이동해야 함<br>
이때 처리 복잡도는 O(n)이며, 데이터를 꺼낼 때마다 이런 처리 작업을 수행해야 한다면 프로그램의 효율성을 기대할 수 없음

## 링 버퍼로 큐 구현하기
디큐 할 때, 배열 안의 원소를 옮기지 않는 큐를 구현하기 위해 **링 버퍼(ring buffer)** 자료구조를 사용<br>
어떤 원소가 맨 앞이고, 맨 끝인지 식별하기 위해 front, rear 변수 사용
> 위에서 언급한 맨 앞 원소와 맨 뒤 원소를 나타내는 용어인 프런트, 리어와 다름! 이건 단순히 변수명일 뿐임

> 여기서 front와 rear는 논리적인 데이터 순서일 뿐 물리적 원소의 순서가 아님

배열의 이름을 que라 하고, que[7], que[8], ... , que[11], que[0], que[1]에 int형 데이터가 저장되어 있다고 가정<br>
이때 front = 7, rear = 2이다.

### 인큐
que[rear], 즉 que[2]에 데이터를 저장하고 rear값을 1 증가시켜 3으로 만듦<br>
이때 처리 복잡도는 O(1)

### 디큐
맨 앞 원소인 que[front], 즉 que[7]의 값인 35를 꺼내고 front 값을 1 증가 시켜 8로 만듦<br>
원소를 옮길 필요가 없기 때문에 처리 복잡도는 O(1)