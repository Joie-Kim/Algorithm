# Dynamic Programming

다이나믹 프로그래밍 알고리즘은 문제를 각가의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. (`기억하기 프로그래밍`이 더 와닿는 표현인 듯)

다이나믹 프로그래밍 알고리즘을 이용하면, 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제, 즉 `최적 부분 구조(Optimal Substructure)`를 갖고 있는 문제를 풀이할 수 있다.

> 최적 부분 구조를 푸는 또 다른 알고리즘으로는 **그리디 알고리즘**이 있다.

> 그리디 알고리즘은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나가는 것이고, 다이나믹 프로그래밍은 중복된 `하위 문제들(Overlapping Subproblem)`의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있다.

## 방법론

1. 상향식(Bottom-Up) : 더 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다. `타뷸레이션(Tabulation)`이라 부르며, 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.
2. 하향식(Top-Down) : 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어나간다. 이 방식을 특별히 `메모이제이션(Memoization)`이라 지칭한다.

### 피보나치 수열로 이해해 보자.

1. 타뷸레이션 (상향식)

   ```jsx
   let result = [0, 1];

   function fib(n) {
     // 처음부터 n까지의 피보나치 값을 구해서 저장한다.
     for (let i = 2; i <= n; i++) {
       result[i] = result[i - 1] + result[i - 2];
     }
     return result[n];
   }
   ```

2. 메모이제이션 (하향식)

   ```jsx
   let result = [0, 1];

   function fib(n) {
     if (n <= 1) return n;

     if (result[n]) return result[n];

     // 재귀로 n에서 0까지 탐색한다.
     result[n] = fib(n - 1) + fib(n - 2);
     return result[n];
   }
   ```
