# Complexity

프로그램의 실행 속도(또는 실행하는 데 필요한 시간)는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.<br>
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 하며, 다음과 같이 2가지로 구분한다.

> 1. 시간 복잡도(time complexity): 실행하는 데 필요한 시간을 평가한다.
> 2. 공간 복잡도(space complexity): 메모리와 파일 공간이 얼마나 필요한지를 평가한다.

<br>

## 예시로 이해하기

선형 검색을 하는 seq_search() 함수가 다음과 같이 있다고 해보자.

```python
def seq_search(a: Sequence, key: Any) -> int:
    i = 0                   # 단계(1)

    while i < n:            # 단계(2)
        if a[i] == key:     # 단계(3)
            return i        # 단계(4): 검색 성공
        i += 1              # 단계(5)

    return -1               # 단계(6): 검색 실패
```

i에 0을 대입하면 단계(1)은 데이터 수와 무관하게 1번 실행된다. 이렇게 **1번만 실행되는 경우**에는 복잡도를 `O(1)`로 나타낸다.<br>
함수에서 값을 반환하는 단게(4), 단게(6)도 마찬가지로 O(1)이다.<br>
배열의 맨 끝에 도달했는지 판단하는 단계(2)와 주목할 원소와 검색할 값이 같은지 판단하는 단계(3)의 평균 실행 횟수는 n/2이다. 이와 같이 **n에 비례하는 횟수만큼 실행되는 경우**의 복잡도는 `O(n)`으로 나타낸다.

> 복잡도를 표기할 때 사용하는 O는 order의 머리글자이며, O(n)은 `n의 오더` 또는 `오더 n`이라고 읽는다.

n이 점점 커지면서 O(n)에 필요한 계산 시간은 n에 비례하여 점점 길어지지만, O(1)에 필요한 계산 시간은 변하지 않는다.<br>
O(f(n))과 O(g(n))의 동작을 연속으로 하는 경우 복잡도는 일반적으로 다음과 같이 나타낸다.

```
O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
```

> max(a, b)는 a와 b 중에 큰 값을 나타내는 함수이다.

즉, 전체 복잡도는 차원이 가장 높은 복잡도를 선택하는 것이다.<br>
따라서 위 선형 검색 알고리즘의 복잡도는 다음과 같이 O(n)이 된다.

```
O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1, n, n, 1, n, 1)) = O(n)
```

<br>

## 복잡도의 대소 관계

O(n)과 O(log n)은 당연히 O(1)보다 크다. 수가 클 수록 알고리즘의 실행 시간이 길어지고 복잡도가 높아진다.

```markdown
`1` < `log n` < `n` < `n log n` < `n^2` < `n^3` < `n^k` < `2^n`
```
